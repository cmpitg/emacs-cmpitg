#!/usr/bin/env expect

package require Tcl 8
package require Tclx
package require cmdline

try {
	array set cmdArgs [::cmdline::getoptions ::argv {
		{shape.arg        "minimal"  "The shape Rmacs takes"}
		{name.arg         ""         "(optional) A unique name used by Emacs server, for interprocess communication.  By default this option is taken from 'shape' if not specified."}
		{timeout.arg      30000      "Timeout (in milisecs) to wait for the server to be alive.  Not in use when 'command' is 'start'."}
		{client-opts.arg  ""         "Extra options passed to Emacsclient invocation.  Not in use when 'command' is 'start'."}
		{no-wait                     "Don't wait for the client session to complete, return immediately.  Not in use when 'command' is 'start'."}
		{new-frame                   "Create a new frame.  Not in use when 'command' is 'start'."}
		{verbose                     "Be verbose, prints options and arguments"}
		{init-dir.arg     ""         "Alternative Rmacs init directory.  Not in use if the server is already started."}
		{init.arg         ""         "Additional init file, loaded after loading base init.  Not in use if the server is already started."}
	} {[rmacs-options] <command> [arguments] ...

Rmacs is an Emacs distribution with the aim to shape Emacs into a specialized tool (called "shape").  The shape is specified by the '--shape' option.  Each shape shared a base configuration with different configurations on top of it.  Currently the following shapes are supported:

  minimal :: General text editing framework
  utils   :: Utility framework
  edit    :: Text editor

After naming a shape, a 'command' needs providing.  The command defines the action to perform.  Some commands need arguments.  The following commands take shape-related options:

  open [path] :: Open a path or URL.  If 'path' is not provided, one a blank buffer.
  eval <sexp> :: Evaluate an Emacs Lisp expression and return the result
  wait        :: Wait until the corresponding server is alive

In addition, Rmacs also supports commands to facilitate the manage of Emacs servers:

  list  :: List the current Emacs server socket names
  kill  :: Kill an Rmacs server, '--name' or '--shape' must be provided
  start :: Start Rmacs server in the foreground, '--name' or '--shape' must be provided

Rmacs runs in a client-server architecture.  Each Rmacs server has a socket name, specified by the '--name' option.  Once the server has started, a normal Emacsclient could connect to the corresponding socket.  This keeps the Rmacs implementation as transparent as possible.

Rmacs works by loading init files from the Rmacs init directory (denoted by the environment variable RMACS_INIT_DIR).  There are 2 main cases where Rmacs works a bit different in the background:
- If 'command' is 'start', Rmacs loads the init file and starts the server in the foreground.  This is useful when running Rmacs as a daemon, particularly in conjunction in a supervisor process such as Sys V Init, SystemD, or Runit, ...
- Otherwise, Rmacs will try to start an Emacs server (if necessary) in the background.  Then it will use Emacsclient to connect to that server to perform the action denoted by 'command'.

Rmacs will always load ~/.emacs-machine-specific-init before and ~/.emacs-machine-specific after all other configurations.

Examples:

  rmacs --shape edit open <path>
	Opens a path as text editor, server is named 'edit'.

  rmacs --shape edit start
	Starts an Rmacs text editor server on the foreground, server is named 'edit'.

  rmacs --shape minimal open
	Runs Rmacs as a general, "minimal" text editor; server is named 'minimal'.

  rmacs --name edit eval <sexp>
	Evals an Emacs Lisp s-expression in an Rmacs server with name 'edit' and shape 'minimal'.

  rmacs --shape edit eval <sexp>
	Evals an Emacs Lisp s-expression in an Rmacs server with name 'edit' and shape 'edit'.

  rmacs list
	Lists all running Emacs server socket names.

  rmacs --name foobar kill
	Kills the server with socket named 'foobar'.

Available Rmacs options:
}]} trap {CMDLINE USAGE} {msg _o} {
	if {[llength $::argv] == 0} {
		puts $msg
		exit 0
	} else {
		puts stderr $msg
		exit 127
	}
}

if {$cmdArgs(verbose)} {
	parray cmdArgs
}

##############################################################################
# Constants
##############################################################################

set ALLOWED_SHAPES {minimal edit utils}

##############################################################################
# Helpers
##############################################################################

proc validateShape {shape} {
	global ALLOWED_SHAPES
	if {[lsearch -exact $ALLOWED_SHAPES $shape] == -1} {
		puts stderr "Error: Shape $shape is not supported"
		exit 1
	}
}

proc standardizeCmdArgs {cmdArgsList} {
	array set cmdArgs $cmdArgsList
	validateShape $cmdArgs(shape)
	if {$cmdArgs(init-dir) eq ""} {
		array set cmdArgs [list init-dir $::env(RMACS_INIT_DIR)]
	}
	if {$cmdArgs(name) eq ""} {
		array set cmdArgs [list name $cmdArgs(shape)]
	}
	if {$cmdArgs(shape) eq "edit"} {
		array set cmdArgs [list emacs-as "nil"]
	} else {
		array set cmdArgs [list emacs-as ":$cmdArgs(shape)"]
	}
	if {$cmdArgs(no-wait)} {
		array set cmdArgs [list client-opts "$cmdArgs(client-opts) --no-wait"]
	}
	if {$cmdArgs(new-frame)} {
		array set cmdArgs [list client-opts "$cmdArgs(client-opts) --create-frame"]
	}
	array set cmdArgs [list shape-init-path [file join $cmdArgs(init-dir) "src" "init-$cmdArgs(shape).el"]]
	return [array get cmdArgs]
}

proc isServerRunning {name} {
	try {
		return [expr [exec emacsclient --socket-name $name --quiet --eval "(+ 1 1)" 2> /dev/null] == 2]
	} trap CHILDSTATUS {_res _opts} {
		return 0
	}
}

proc rmacsWait {name timeout} {
	set timeToWait 200
	set retries [expr $timeout / $timeToWait]
	while {$retries > 0} {
		if {[isServerRunning $name]} {
			return 1
		}
		puts "Waiting for server '$name', retries = $retries..."
		set retries [expr $retries - 1]
		after $timeToWait
	}
	puts stderr "Timed out when waiting for '$name' to start..."
	exit 2
}

proc rmacsStart {name emacsAs shapeInitPath init bgDaemon verbose} {
	set cmd [list emacs -Q]
	set cmd [concat $cmd [list --eval "(setq *emacs-as-tool* $emacsAs)"]]
	set cmd [concat $cmd [list --eval "(setq server-name \"$name\")"]]
	set cmd [concat $cmd [list --load $shapeInitPath]]
	if {$init ne ""} {
		set cmd [concat $cmd [list --load $init]]
	}
	if {$bgDaemon} {
		set cmd [concat $cmd [list --bg-daemon=$name]]
	} else {
		set cmd [concat $cmd [list --fg-daemon=$name]]
	}
	if {$verbose} {
		puts "Server command: $cmd"
	}
	if {$bgDaemon} {
		return [exec {*}$cmd <@ stdin >@ stdout 2>@ stderr]
	} else {
		execl [lindex $cmd 0] [lrange $cmd 1 end]
	}
}

proc rmacsEval {name clientOpts argList verbose} {
	set cmd [list emacsclient --quiet]
	set cmd [concat $cmd [list --socket-name $name]]
	if {$clientOpts ne ""} {
		set cmd [concat $cmd $clientOpts]
	}
	set cmd [concat $cmd [list --eval {*}$argList]]
	if {$verbose} {
		puts "Client command: $cmd"
	}
	# The following command doesn't work, why?
	# return [interact [spawn -noecho {*}$cmd]]
	return [exec {*}$cmd <@ stdin >@ stdout 2>@ stderr]
}

proc rmacsList {} {
	set uid [exec id -u]
	exec mkdir -p /tmp/emacs$uid <@ stdin >@ stderr 2>@ stderr
	exec chmod 700 /tmp/emacs$uid <@ stdin >@ stderr 2>@ stderr
	return [exec ls -1 /tmp/emacs$uid/ <@ stdin >@ stderr 2>@ stderr]
}

proc rmacsKill {name verbose} {
	set cmd [list emacsclient --quiet]
	set cmd [concat $cmd [list --socket-name $name]]
	set cmd [concat $cmd [list --eval "(kill-emacs)"]]
	if {$verbose} {
		puts "Client command: $cmd"
	}
	return [interact [spawn -noecho {*}$cmd]]
}

proc makeSureServerIsRunning {argList} {
	array set args $argList
	if {![isServerRunning $args(name)]} {
		rmacsStart $args(name) $args(emacs-as) $args(shape-init-path) $args(init) 1 $args(verbose)
		rmacsWait $args(name) $args(timeout)
	}
}

##############################################################################
# Main
##############################################################################

# Makes Emacs GPG-aware when there is a TTY
if {[dict exists [fconfigure stdin] -mode]} {
	set ::env(GPG_TTY) [exec tty]
}

array set args [standardizeCmdArgs [array get cmdArgs]]
set mainCommand [lindex $::argv 0]
set mainArgs [lrange $::argv 1 end]

if {$args(verbose)} {
	parray args
	puts "Main command and arguments: $::argv"
}

switch $mainCommand {
	list {
		rmacsList
	}
	kill {
		if {[isServerRunning $args(name)]} {
			rmacsKill $args(name) $args(verbose)
		}
	}
	wait {
		rmacsWait $args(name) $args(timeout)
	}
	start {
		if {[isServerRunning $args(name)]} {
			puts stderr "Error: Server '$args(name)' is running..."
		} else {
			rmacsStart $args(name) $args(emacs-as) $args(shape-init-path) $args(init) 0 $args(verbose)
		}
		exit 15
	}
	eval {
		makeSureServerIsRunning [array get args]
		rmacsEval $args(name) $args(client-opts) $mainArgs $args(verbose)
	}
	open {
		makeSureServerIsRunning [array get args]

		set rawPath [lindex $mainArgs 0]
		switch -glob $rawPath {
			/* {
				set path $rawPath
			}
			default {
				# Do not use `file join` since rawPath might contain non-path elements
				set path "[pwd]/$rawPath"
			}
		}

		if {[llength $mainArgs] == 0} {
			set sexp {(switch-to-buffer "*Blank*")}
		} elseif {$args(new-frame) && !$args(no-wait)} {
			set sexp "(prog1 (~smart-open-file \"$path\") (setq-local local/delete-frame-on-close (selected-frame)))"
		} else {
			set sexp "(~smart-open-file \"$path\")"
		}

		rmacsEval $args(name) $args(client-opts) [list $sexp] $args(verbose)
	}
}

# Local Variables:
# indent-tabs-mode: t
# End:
