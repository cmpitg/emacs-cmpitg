#!/bin/bash

export GPG_TTY=$(tty)

if [[ "${1}" = "--help" ]]; then
	cat <<EOF
Usage: rmacs [rmacs-options] <command> [arguments] ...

Rmacs is a Re-enforced eMacs, shaping Emacs into one of the supported tools
(called 'shapes') specified below.

'command' is one of the following:

  edit   :: Run Rmacs as text editor
  mail   :: Run Rmacs as mail browser
  note   :: Run Rmacs as note taker
  file   :: Run Rmacs as file manager
  start  :: Run a minimal Rmacs without additional configuration
  eval   :: Evals an arbitrary Emacs Lisp expression

Rmacs works by loading an init file from the Rmacs init directory denoted by
the environment variable RMACS_INIT_DIR.

Rmacs starts an Emacs server with 'server-start' if not started.

One or more Rmacs options might be specificied before 'command':

  --name <server-name>  :: A unique name used by Emacs server, for
                           interprocess communication.
  --no-wait             :: Don't wait for the Rmacs session to complete,
                           return immediately.
  --new-frame           :: Create a new frame.
  --verbose             :: Print command, options, and arguments.

  --init-dir <dir>      :: Alternative base init directory.  Not in use if
                           the server is already started or if 'command' is
                           'start'.
  --init <path>         :: Additional init file, loaded after loading base
                           init.  Not in use if the server is already started.

If '--name' is not specified:

  text editor uses server name 'edit'
  mail browser uses server name 'mail'
  note taker uses server name 'note'
  file taker uses server name 'file'
  otherwise, server name is set to 'nil'

The load of custom inits are supported.  Rmacs will load
~/.emacs-machine-specific-init before and ~/.emacs-machine-specific after
loading Rmacs configuration.

Examples:

  rmacs edit <path>
    Opens a file.

  rmacs edit <path>:<line-number>
    Opens a file, jumps to a specific line.

  rmacs edit <path>:/<pattern>/
    Opens a file, jumps to the first line containing a specific pattern.

  rmacs mail
    Runs Rmacs as mail browser.

  rmacs note
    Runs Rmacs as note taker.

  rmacs file
    Runs Rmacs as file browser.

  rmacs minimal
    Runs a minimal Rmacs configuration.

  rmacs eval <expression>
    Evals an Emacs Lisp expression.

EOF
	exit 0
fi

##############################################################################
# Reading commands and arguments
##############################################################################

command_=""
emacs_as_=""
name_=""
no_wait_="false"
new_frame_="false"
rmacs_init_dir_="${RMACS_INIT_DIR:-}"
init_=""
verbose_="false"
tmpdir_="${TMPDIR:-/tmp/${USER}}"

while [[ "${1}" == --* ]]; do
	case "${1}" in
		--name)
			name_="${2}"
			shift
			;;
		--init)
			init_="${2}"
			shift
			;;
		--init-dir)
			rmacs_init_dir_="${2}"
			shift
			;;
		--no-wait)
			no_wait_=true
			;;
		--new-frame)
			new_frame_=true
			;;
		--verbose)
			verbose_=true
			;;
		*)
			echo Invalid options "${1}". >&2
			exit 2
	esac
	shift
done

case "${1}" in
	edit|eval)
		command_="${1}"
		;;
	mail)
		command_=mail
		;;
	note)
		command_=note
		;;
	file)
		command_=file
		;;
	"")
		echo Missing command.  See rmacs --help for usage. >&2
		exit 1
		;;
	*)
		echo Invalid command "${1}". >&2
		exit 1
		;;
esac
shift

if [[ -z "${name_}" ]]; then
	name_=${command_}
fi

if [[ "${command_}" = "edit" ]]; then
	emacs_as_="nil"
else
	emacs_as_=":${command_}"
fi

rmacs_init_="${rmacs_init_dir_}/init-${command_}.el"

##############################################################################
# emacsclient options
##############################################################################

socket_path_="/tmp/emacs${UID}/${name_}"
emacsclient_options_="${EMACS_CLIENT_OPTIONS}"

if [[ "${no_wait_}" = "true" ]]; then
	emacsclient_options_="${emacsclient_options_} --no-wait"
fi
if [[ "${new_frame_}" = "true" ]]; then
	emacsclient_options_="${emacsclient_options_} --create-frame"
fi

##############################################################################

if [[ "${verbose_}" = "true" ]]; then
	echo Command: ${command_}
	echo Server name: ${name_}
	echo Socket path: ${socket_path_}
	echo No wait: ${no_wait_}
	echo New frame when running: ${new_frame_}
	echo Rmacs init directory: ${rmacs_init_dir_}
	echo Rmacs init file: ${rmacs_init_}
	if ! [[ "${init_}" = "" ]]; then
		echo Init: ${init_}
	fi
	echo Additional Emacs client options: ${emacsclient_options_}
	echo "Variable *emacs-as-tool*: ${emacs_as_}"
fi

##############################################################################
# Helpers
##############################################################################

server_running_p() {
	local eval_result_=$(emacsclient --socket-name ${socket_path_} \
	                                 --quiet --eval '(+ 1 1)' 2>/dev/null)
	if [[ "${eval_result_}" = "2" ]]; then
		echo true
	else
		echo false
	fi
}

wait_until_server_is_running() {
	while [[ $(server_running_p) = "false" ]]; do
		sleep 1
	done
}

##############################################################################
# Main
##############################################################################

if [[ $(server_running_p) = "false" ]]; then
	if [[ "${verbose_}" = "true" ]]; then
		echo Server ${name_} is not running.  Starting...
	fi

	if [[ -z "${init_}" ]]; then
		nohup emacs -Q \
			--eval "(setq *emacs-as-tool* ${emacs_as_})" \
			--eval '(setq server-name "'${name_}'")' \
			--eval '(setq server-socket-dir "'/tmp/emacs${UID}'")' \
			--load "${rmacs_init_}" \
			>"${tmpdir_}/emacs-${name_}.out" \
			2>"${tmpdir_}/emacs-${name_}.err" &
	else
		nohup emacs -Q \
			--eval "(setq *emacs-as-tool* ${emacs_as_})" \
			--eval '(setq server-name "'${name_}'")' \
			--eval '(setq server-socket-dir "'/tmp/emacs${UID}'")' \
			--load "${rmacs_init_}" \
			--load "${init_}" \
			>"${tmpdir_}/emacs-${name_}.out" \
			2>"${tmpdir_}/emacs-${name_}.err" &
	fi
fi

wait_until_server_is_running

case "${command_}" in
	eval)
		if [[ -z "${1}" ]]; then
			echo No expression to eval. >&2
			exit 2
		fi

		emacsclient --quiet \
			--socket-name "${socket_path_}" \
			${emacsclient_options_} \
			--eval "$@"
		;;
	edit|minimal)
		if [[ "${1}" == /* ]]; then
			path_="$@"
		elif ! [[ -z "${1}" ]]; then
			path_="${PWD}/$@"
		fi

		if ! [[ -z "${path_}" ]]; then
			emacsclient --quiet \
						--socket-name "${socket_path_}" \
						${emacsclient_options_} \
						"${path_}"
			# --eval '(toolbox:open-file "'${path_}'")'
		fi
		;;
	file)
		# TODO: Open directory with file browser
		;;
esac
